{"id":489105985,"lang":"cpp","time":"1 year, 1 month","timestamp":1620199269,"status_display":"Accepted","runtime":"156 ms","url":"/submissions/detail/489105985/","is_pending":"Not Pending","title":"Path with Maximum Probability","memory":"64.8 MB","code":"struct node{\n    int to;\n    double wid;\n};\nbool operator<(node a,node b){\n    return a.wid<b.wid;\n}\nclass Solution {\npublic:\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succ, int start, int end) {\n        vector<node> g[n];\n        vector<double> dis(n,0);\n        vector<bool> vis(n,false);\n        for(int i=0;i<edges.size();i++){\n            g[edges[i][0]].emplace_back(node{edges[i][1],succ[i]});\n            g[edges[i][1]].emplace_back(node{edges[i][0],succ[i]});\n        }\n        priority_queue<node> pq;\n        pq.push(node{start,1});\n        while(!pq.empty()){\n            auto t = pq.top();\n            pq.pop();\n            if(vis[t.to]==true) continue;\n            vis[t.to]=true;\n            for(int i=0;i<g[t.to].size();i++){\n                if(t.wid*g[t.to][i].wid>dis[g[t.to][i].to]){\n                    dis[g[t.to][i].to]=t.wid*g[t.to][i].wid;\n                    pq.push(node{g[t.to][i].to,dis[g[t.to][i].to]});\n                }\n            }\n        }\n        return dis[end];\n    }\n};","compare_result":"1111111111111111","title_slug":"path-with-maximum-probability"}